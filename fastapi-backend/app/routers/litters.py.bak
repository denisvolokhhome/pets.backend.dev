"""
Litters router for managing litter records.

This module provides CRUD operations for litter management including:
- Creating and updating litter records
- Listing litters with filtering options
- Managing litter information and associations with pets
"""
from typing import List, Optional
import uuid

from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from app.database import get_async_session
from app.models.litter import Litter
from app.models.litter_pet import LitterPet
from app.models.pet import Pet
from app.models.breed import Breed
from app.models.location import Location
from app.schemas.litter import LitterCreate, LitterRead, LitterUpdate, LitterResponse, LitterStatus, PetAssignment, PuppyBatch


router = APIRouter(
    prefix="/api/litters",
    tags=["litters"],
    responses={
        404: {"description": "Litter not found"},
    }
)


@router.post("/", response_model=LitterResponse, status_code=status.HTTP_201_CREATED)
async def create_litter(
    litter_data: LitterCreate,
    session: AsyncSession = Depends(get_async_session),
) -> dict:
    """
    Create a new litter record.
    
    This endpoint is public and does not require authentication.
    A litter represents a breeding operation tracking parent pets and puppies.
    
    **Optional fields:**
    - description: Additional information about the litter
    
    **Example:**
    ```json
    {
        "description": "First litter of 2024"
    }
    ```
    
    **Returns:** The created litter record with generated ID and status "Started"
    
    **Requirements:** 4.1, 4.3, 4.4, 4.5
    """
    # Create new litter instance with status "Started"
    litter = Litter(
        description=litter_data.description,
        status=LitterStatus.STARTED.value,
    )
    
    session.add(litter)
    await session.commit()
    await session.refresh(litter)
    
    # Return LitterResponse format
    return {
        "id": litter.id,
        "description": litter.description,
        "status": litter.status,
        "created_at": litter.created_at,
        "updated_at": litter.updated_at,
        "parent_pets": None,
        "puppies": None
    }


@router.get("/", response_model=List[LitterResponse])
async def list_litters(
    session: AsyncSession = Depends(get_async_session),
    location_id: Optional[int] = Query(None, description="Filter by location ID"),
    status: Optional[str] = Query(None, description="Filter by status"),
    breed_id: Optional[int] = Query(None, description="Filter by breed ID"),
    skip: int = 0,
    limit: int = 100,
) -> List[dict]:
    """
    List all litters with optional filtering.
    
    This endpoint is public and does not require authentication.
    Results are ordered by created_at descending (most recent first).
    Voided litters are excluded by default.
    
    **Query Parameters:**
    - location_id: Filter litters by location (derived from parent pets)
    - status: Filter by litter status (Started, InProcess, Done, Voided)
    - breed_id: Filter litters by breed (from parent pets)
    - skip: Number of records to skip (pagination)
    - limit: Maximum number of records to return
    
    **Returns:** List of litters with nested parent_pets and puppies
    """
    # Start with base query
    query = select(Litter).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    
    # Exclude voided litters by default (unless explicitly requested)
    if status != "Voided":
        query = query.where(Litter.status != LitterStatus.VOIDED.value)
    
    # Apply status filter if provided
    if status:
        query = query.where(Litter.status == status)
    
    # Execute query to get litters
    result = await session.execute(query)
    litters = result.scalars().all()
    
    # Build response with parent pets and puppies
    response_litters = []
    for litter in litters:
        # Get parent pets from litter_pets junction table
        parent_pets = []
        parent_pet_locations = set()
        parent_pet_breeds = set()
        
        for litter_pet in litter.litter_pets:
            pet = litter_pet.pet
            parent_pets.append({
                "id": str(pet.id),
                "name": pet.name,
                "breed_name": pet.breed.name if pet.breed else None,
                "breed_id": pet.breed_id,
                "location_name": pet.location.name if pet.location else None,
                "location_id": pet.location_id,
                "gender": pet.gender
            })
            if pet.location_id:
                parent_pet_locations.add(pet.location_id)
            if pet.breed_id:
                parent_pet_breeds.add(pet.breed_id)
        
        # Apply location filter
        if location_id and location_id not in parent_pet_locations:
            continue
        
        # Apply breed filter
        if breed_id and breed_id not in parent_pet_breeds:
            continue
        
        # Get puppies (pets with this litter_id)
        puppies = []
        for pet in litter.pets:
            puppies.append({
                "id": str(pet.id),
                "name": pet.name,
                "gender": pet.gender,
                "birth_date": pet.date_of_birth.isoformat() if pet.date_of_birth else None,
                "microchip": pet.microchip
            })
        
        response_litters.append({
            "id": litter.id,
            "description": litter.description,
            "status": litter.status,
            "created_at": litter.created_at,
            "updated_at": litter.updated_at,
            "parent_pets": parent_pets if parent_pets else None,
            "puppies": puppies if puppies else None
        })
    
    # Apply pagination
    response_litters = response_litters[skip:skip + limit]
    
    return response_litters


@router.get("/{litter_id}", response_model=LitterResponse)
async def get_litter(
    litter_id: int,
    session: AsyncSession = Depends(get_async_session),
) -> dict:
    """
    Get a single litter by ID with full details.
    
    This endpoint is public and does not require authentication.
    Returns litter with nested parent_pets and puppies.
    
    **Returns:** LitterResponse with parent pets and puppies
    
    **Requirements:** 7.2, 7.3, 7.4, 7.5
    """
    # Query litter with relationships eagerly loaded
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one_or_none()
    
    if litter is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Litter not found"
        )
    
    # Build parent pets list from litter_pets junction table
    parent_pets = []
    for litter_pet in litter.litter_pets:
        pet = litter_pet.pet
        parent_pets.append({
            "id": str(pet.id),
            "name": pet.name,
            "breed_name": pet.breed.name if pet.breed else None,  # Changed from "breed" to "breed_name"
            "breed_id": pet.breed_id,
            "location_name": pet.location.name if pet.location else None,  # Changed from "location" to "location_name"
            "location_id": pet.location_id,
            "gender": pet.gender
        })
    
    # Build puppies list from pets with this litter_id
    # Query puppies directly to ensure we get them
    puppy_query = select(Pet).where(Pet.litter_id == litter.id).options(
        selectinload(Pet.breed),
        selectinload(Pet.location)
    )
    puppy_result = await session.execute(puppy_query)
    puppy_pets = puppy_result.scalars().all()
    
    puppies = []
    for pet in puppy_pets:
        puppies.append({
            "id": str(pet.id),
            "name": pet.name,
            "gender": pet.gender,
            "birth_date": pet.date_of_birth.isoformat() if pet.date_of_birth else None,
            "microchip": pet.microchip
        })
    
    # Return LitterResponse format
    return {
        "id": litter.id,
        "description": litter.description,
        "status": litter.status,
        "created_at": litter.created_at,
        "updated_at": litter.updated_at,
        "parent_pets": parent_pets if parent_pets else None,
        "puppies": puppies if puppies else None
    }


@router.put("/{litter_id}", response_model=LitterResponse)
async def update_litter(
    litter_id: int,
    litter_update: LitterUpdate,
    session: AsyncSession = Depends(get_async_session),
) -> dict:
    """
    Update a litter record.
    
    Only provided fields will be updated (currently only description).
    The updated_at timestamp is automatically updated.
    This endpoint is public and does not require authentication.
    
    **Requirements:** 8.1, 8.2, 8.5
    """
    # Fetch the litter with relationships
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one_or_none()
    
    if litter is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Litter not found"
        )
    
    # Update fields that were provided
    update_data = litter_update.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(litter, field, value)
    
    # Commit changes (updated_at will be automatically updated by SQLAlchemy)
    await session.commit()
    await session.refresh(litter)
    
    # Build parent pets list from litter_pets junction table
    parent_pets = []
    for litter_pet in litter.litter_pets:
        pet = litter_pet.pet
        parent_pets.append({
            "id": str(pet.id),
            "name": pet.name,
            "breed_name": pet.breed.name if pet.breed else None,
            "breed_id": pet.breed_id,
            "location": pet.location.name if pet.location else None,
            "location_id": pet.location_id,
            "gender": pet.gender
        })
    
    # Build puppies list from pets with this litter_id
    puppy_query = select(Pet).where(Pet.litter_id == litter.id).options(
        selectinload(Pet.breed),
        selectinload(Pet.location)
    )
    puppy_result = await session.execute(puppy_query)
    puppy_pets = puppy_result.scalars().all()
    
    puppies = []
    for pet in puppy_pets:
        puppies.append({
            "id": str(pet.id),
            "name": pet.name,
            "gender": pet.gender,
            "birth_date": pet.date_of_birth.isoformat() if pet.date_of_birth else None,
            "microchip": pet.microchip
        })
    
    # Return LitterResponse format
    return {
        "id": litter.id,
        "description": litter.description,
        "status": litter.status,
        "created_at": litter.created_at,
        "updated_at": litter.updated_at,
        "parent_pets": parent_pets if parent_pets else None,
        "puppies": puppies if puppies else None
    }


@router.post("/{litter_id}/assign-pets", response_model=LitterResponse)
async def assign_pets_to_litter(
    litter_id: int,
    pet_assignment: PetAssignment,
    session: AsyncSession = Depends(get_async_session),
) -> dict:
    """
    Assign parent pets to a litter.
    
    This endpoint assigns exactly 2 parent pets to a litter and updates the litter status to "InProcess".
    Both pets must exist and must have the same location_id.
    This endpoint is public and does not require authentication.
    
    **Request Body:**
    ```json
    {
        "pet_ids": ["uuid1", "uuid2"]
    }
    ```
    
    **Validation Rules:**
    - Exactly 2 pets must be provided
    - Both pets must exist in the database
    - Both pets must have the same location_id
    - Returns 400 error if validation fails
    
    **Returns:** LitterResponse with updated status "InProcess" and parent_pets
    
    **Requirements:** 3.1, 3.4, 5.1, 5.2, 5.3, 5.4
    """
    # Fetch the litter
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one_or_none()
    
    if litter is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Litter not found"
        )
    
    # Validate both pets exist
    pet_ids = pet_assignment.pet_ids
    pets_query = select(Pet).where(Pet.id.in_(pet_ids)).options(
        selectinload(Pet.breed),
        selectinload(Pet.location)
    )
    pets_result = await session.execute(pets_query)
    pets = pets_result.scalars().all()
    
    if len(pets) != 2:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Both pets must exist in the database"
        )
    
    # Validate both pets have the same location_id
    pet1, pet2 = pets[0], pets[1]
    if pet1.location_id != pet2.location_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Both pets must have the same location"
        )
    
    # Create entries in litter_pets junction table
    for pet in pets:
        litter_pet = LitterPet(
            litter_id=litter.id,
            pet_id=pet.id
        )
        session.add(litter_pet)
    
    # Update litter status to "InProcess"
    litter.status = LitterStatus.IN_PROCESS.value
    
    # Commit changes (updated_at will be automatically updated)
    await session.commit()
    await session.refresh(litter)
    
    # Reload litter with relationships to get the newly assigned pets
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one()
    
    # Build parent pets list from litter_pets junction table
    parent_pets = []
    for litter_pet in litter.litter_pets:
        pet = litter_pet.pet
        parent_pets.append({
            "id": str(pet.id),
            "name": pet.name,
            "breed_name": pet.breed.name if pet.breed else None,
            "breed_id": pet.breed_id,
            "location": pet.location.name if pet.location else None,
            "location_id": pet.location_id,
            "gender": pet.gender
        })
    
    # Build puppies list from pets with this litter_id
    puppy_query = select(Pet).where(Pet.litter_id == litter.id).options(
        selectinload(Pet.breed),
        selectinload(Pet.location)
    )
    puppy_result = await session.execute(puppy_query)
    puppy_pets = puppy_result.scalars().all()
    
    puppies = []
    for pet in puppy_pets:
        puppies.append({
            "id": str(pet.id),
            "name": pet.name,
            "gender": pet.gender,
            "birth_date": pet.date_of_birth.isoformat() if pet.date_of_birth else None,
            "microchip": pet.microchip
        })
    
    # Return LitterResponse format
    return {
        "id": litter.id,
        "description": litter.description,
        "status": litter.status,
        "created_at": litter.created_at,
        "updated_at": litter.updated_at,
        "parent_pets": parent_pets if parent_pets else None,
        "puppies": puppies if puppies else None
    }


@router.post("/{litter_id}/add-puppies", response_model=LitterResponse)
async def add_puppies_to_litter(
    litter_id: int,
    puppy_batch: PuppyBatch,
    session: AsyncSession = Depends(get_async_session),
) -> dict:
    """
    Add puppies to a litter.
    
    This endpoint creates pet records for each puppy and associates them with the litter.
    The litter status is updated to "Done" after puppies are added.
    Location and breed are derived from the parent pets.
    This endpoint is public and does not require authentication.
    
    **Request Body:**
    ```json
    {
        "puppies": [
            {
                "name": "Puppy 1",
                "gender": "Male",
                "birth_date": "2024-01-15",
                "microchip": "123456789"
            }
        ]
    }
    ```
    
    **Validation Rules:**
    - Litter must have parent pets assigned
    - At least one puppy must be provided
    - Each puppy must have name, gender, and birth_date
    - Gender must be "Male" or "Female"
    - Returns 400 error if validation fails
    
    **Returns:** LitterResponse with updated status "Done" and puppies
    
    **Requirements:** 6.1, 6.2, 6.3, 6.4, 6.5
    """
    # Fetch the litter with relationships
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one_or_none()
    
    if litter is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Litter not found"
        )
    
    # Validate litter has parent pets assigned
    if not litter.litter_pets or len(litter.litter_pets) == 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Litter must have parent pets assigned before adding puppies"
        )
    
    # Derive location and breed from parent pets
    parent_pets = [litter_pet.pet for litter_pet in litter.litter_pets]
    
    # Get location from first parent pet (they should all have the same location)
    location_id = parent_pets[0].location_id if parent_pets[0].location_id else None
    
    # Get breed - if both parents have the same breed, use that; otherwise use first parent's breed
    breed_ids = [pet.breed_id for pet in parent_pets if pet.breed_id]
    breed_id = breed_ids[0] if breed_ids else None
    
    # Get user_id from first parent pet
    user_id = parent_pets[0].user_id
    
    # Create pet records for each puppy
    created_puppies = []
    for puppy_input in puppy_batch.puppies:
        puppy = Pet(
            name=puppy_input.name,
            gender=puppy_input.gender,
            date_of_birth=puppy_input.birth_date,
            microchip=puppy_input.microchip,
            litter_id=litter.id,
            location_id=location_id,
            breed_id=breed_id,
            user_id=user_id,
            is_puppy=True
        )
        session.add(puppy)
        created_puppies.append(puppy)
    
    # Update litter status to "Done"
    litter.status = LitterStatus.DONE.value
    
    # Commit changes (updated_at will be automatically updated)
    await session.commit()
    
    # Refresh all created puppies to get their IDs
    for puppy in created_puppies:
        await session.refresh(puppy)
    
    # Reload litter with relationships to get the newly added puppies
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one()
    
    # Build parent pets list from litter_pets junction table
    parent_pets_list = []
    for litter_pet in litter.litter_pets:
        pet = litter_pet.pet
        parent_pets_list.append({
            "id": str(pet.id),
            "name": pet.name,
            "breed_name": pet.breed.name if pet.breed else None,
            "breed_id": pet.breed_id,
            "location": pet.location.name if pet.location else None,
            "location_id": pet.location_id,
            "gender": pet.gender
        })
    
    # Build puppies list from pets with this litter_id
    puppy_query = select(Pet).where(Pet.litter_id == litter.id).options(
        selectinload(Pet.breed),
        selectinload(Pet.location)
    )
    puppy_result = await session.execute(puppy_query)
    puppy_pets = puppy_result.scalars().all()
    
    puppies = []
    for pet in puppy_pets:
        puppies.append({
            "id": str(pet.id),
            "name": pet.name,
            "gender": pet.gender,
            "birth_date": pet.date_of_birth.isoformat() if pet.date_of_birth else None,
            "microchip": pet.microchip
        })
    
    # Return LitterResponse format
    return {
        "id": litter.id,
        "description": litter.description,
        "status": litter.status,
        "created_at": litter.created_at,
        "updated_at": litter.updated_at,
        "parent_pets": parent_pets_list if parent_pets_list else None,
        "puppies": puppies if puppies else None
    }


@router.delete("/{litter_id}", response_model=LitterResponse)
async def delete_litter(
    litter_id: int,
    session: AsyncSession = Depends(get_async_session),
) -> dict:
    """
    Void/cancel a litter record (soft delete).
    
    This endpoint updates the litter status to "Voided" and maintains the litter record
    for historical tracking. The litter will be excluded from default listings but
    can still be retrieved by ID or by explicitly filtering for voided litters.
    This endpoint is public and does not require authentication.
    
    **Returns:** LitterResponse with updated status "Voided"
    
    **Requirements:** 9.1, 9.2, 9.3, 9.4, 9.5
    """
    # Fetch the litter with relationships
    query = select(Litter).where(Litter.id == litter_id).options(
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.breed),
        selectinload(Litter.litter_pets).selectinload(LitterPet.pet).selectinload(Pet.location),
        selectinload(Litter.pets).selectinload(Pet.breed),
        selectinload(Litter.pets).selectinload(Pet.location)
    )
    result = await session.execute(query)
    litter = result.scalar_one_or_none()
    
    if litter is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Litter not found"
        )
    
    # Update litter status to "Voided" (soft delete)
    litter.status = LitterStatus.VOIDED.value
    
    # Commit changes (updated_at will be automatically updated)
    await session.commit()
    await session.refresh(litter)
    
    # Build parent pets list from litter_pets junction table
    parent_pets = []
    for litter_pet in litter.litter_pets:
        pet = litter_pet.pet
        parent_pets.append({
            "id": str(pet.id),
            "name": pet.name,
            "breed_name": pet.breed.name if pet.breed else None,
            "breed_id": pet.breed_id,
            "location": pet.location.name if pet.location else None,
            "location_id": pet.location_id,
            "gender": pet.gender
        })
    
    # Build puppies list from pets with this litter_id
    puppy_query = select(Pet).where(Pet.litter_id == litter.id).options(
        selectinload(Pet.breed),
        selectinload(Pet.location)
    )
    puppy_result = await session.execute(puppy_query)
    puppy_pets = puppy_result.scalars().all()
    
    puppies = []
    for pet in puppy_pets:
        puppies.append({
            "id": str(pet.id),
            "name": pet.name,
            "gender": pet.gender,
            "birth_date": pet.date_of_birth.isoformat() if pet.date_of_birth else None,
            "microchip": pet.microchip
        })
    
    # Return LitterResponse format
    return {
        "id": litter.id,
        "description": litter.description,
        "status": litter.status,
        "created_at": litter.created_at,
        "updated_at": litter.updated_at,
        "parent_pets": parent_pets if parent_pets else None,
        "puppies": puppies if puppies else None
    }
